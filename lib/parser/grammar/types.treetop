grammar Types

  rule type
    [A-Z] [a-zA-Z0-9_]* {
      def to_ast
        Type.new(text_value, self)
      end
    }
  end

  rule type_expression
    type_infix_chain
  end

  rule type_primary
    type_variable / type
  end

  rule type_infix_chain
    type_primary:type_primary (type_infix_op type_expression)* {
      def to_ast
        # Consume left to right
        # Start with the leftmost primary
        left = type_primary.to_ast

        elements[1].elements.each do |op_and_right|
          op, right = op_and_right.elements.map(&:to_ast)
          left = Ast::FunctionCall.new(op, [left, right], op_and_right.type_infix_op)
        end

        return left
      end
    }
  end

  rule type_sig
    ':' space? type:type_expression {
      def to_ast
        Ast::TypeSig.new(type.to_ast, self)
      end
    }
  end

  # Type variables start with a ' to differentiate them from normal variables.
  # This differentiation lets you only parameterize the at the class level,
  # then reuse the variables anywhere in the class
  rule type_variable
    '\'' [a-z] [a-zA-Z0-9_]* {
      def to_ast
        Ast::TypeVariable.new(text_value[1..-1], self)
      end
    }
  end

  rule type_infix_op
    # We want to process lower precedence operators first
    space? operator:('||' / '&&' / '|' / '&') space? {
      def to_ast
        operator.text_value
      end
    }
  end

end