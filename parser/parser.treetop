grammar StoutLang
  include Types
  include Methods
  include Functions
  include Strings
  include Ifs
  include Lists

  rule program
    space? program:(assign:assignment space?)* {
      def to_ast
        Ast::Block.new(program.elements.map {|e| e.assign.to_ast })
      end
    }
  end

  rule expression
    exp:(assignment) {
      def to_ast
        exp.to_ast
      end
    }
  end

  rule assignment
    ident:identifier space? assign_type:type_sig? space? '=' space? exp:expression {
      def to_ast
        assign_type_sig = assign_type.respond_to?(:to_ast) ? assign_type.to_ast : nil

        Ast::Assignment.new(ident.to_ast, exp.to_ast, assign_type_sig)
      end
    } / exp:define_method {
      def to_ast
        exp.to_ast
      end
    }
  end

  rule define_method
    'def ' method_name:method_name space? args:(method_args:method_args)? space? block:block {
      def to_ast
        Ast::Def.new(method_name.to_ast, args&.method_args&.to_ast, block.to_ast)
      end
    } / infix:infix_chain {
      def to_ast
        infix.to_ast
      end
    }
  end

  rule infix_chain
    method_chain (infix_op expression)* {
      def to_ast
        # Consume left to right
        # Start with the leftmost primary
        left = method_chain.to_ast
        elements[1].elements.each do |op_and_right|
          op, right = op_and_right.elements.map(&:to_ast)
          left = Ast::FunctionCall.new(op, [left, right])
        end

        return left
      end
    } / func:function_call_with_args {
      def to_ast
        func.to_ast
      end
    }
  end


  rule function_call_with_args
    # Function calls without args parse as an identifier and we have to convert
    # them at compile time.

    method_name space? args:method_args space? block:block? {
      # Doesn't return the AST node, just the parts we need to build in
      # method chain
      def to_ast
        function_name = method_name.to_ast

        # parens are required in function_call_with_args
        args_ast = args.respond_to?(:to_ast) ? args.to_ast : []

        # If a block was passed, add it to the args
        args_ast << block.to_ast if block && block.respond_to?(:to_ast)

        Ast::FunctionCall.new( function_name, args_ast)
      end
    }
  end

  rule boolean_literal
    lit:(true_literal / false_literal) {
      def to_ast
        lit.to_ast
      end
    }
  end

  rule true_literal
    'true' {
      def to_ast
        TrueLiteral.new
      end
    }
  end

  rule false_literal
    'false' {
      def to_ast
        FalseLiteral.new
      end
    }
  end
  

  rule block
    '{' program '}' {
      def to_ast
        program.to_ast
      end
    }
  end


  rule primary
    ident:(if_expression / list / boolean_literal / function_call_with_args / identifier / float / integer / string / parens) {
      def to_ast
        ident.to_ast
      end
    }
  end

  rule infix_op
    # We want to process lower precedence operators first
    space? operator:('+' / '-' / '*' / '/') space? {
      def to_ast
        operator.text_value
      end
    }
  end

  rule float
    float:(('+' / '-')? [0-9]+ ('.' [0-9]+) (exponent)?) {
      def to_ast
        FloatLiteral.new(float.text_value.to_f)
      end
    }
  end

  rule exponent
    [eE] '-'? [0-9]+
  end

  rule integer
    ('+' / '-')? [0-9]+ {
      def to_ast
        IntegerLiteral.new(text_value.to_i)
      end
    }
  end

  rule digit
    [0-9]
  end


  rule escaped_char
    '\\' ["] / '\\' [n] / '\\' [t] / '\\' [\\]
  end

  # Variable names
  rule identifier
    [a-z] [a-zA-Z0-9_]* {
      def to_ast
        Ast::Identifier.new(text_value)
      end
    }
  end

  rule parens
    '(' exp:expression ')' {
      def to_ast
        exp.to_ast
      end
    }
  end


  rule space
    [\s\n\r]+
  end

  rule nbsp
    [\s]+
  end

  rule line_break
    [\n\r;]+
  end

  rule eof
    !.
  end
  
end